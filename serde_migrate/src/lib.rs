#![allow(clippy::needless_doctest_main)]
//! # Serde Migrate
//!
//! This crate provides an easy solution for handling migrations with `serde`.
//!
//! The main idea is that:
//!
//! * You provide a struct, with fields marked with attributes to indicate when they were introduced, and when they were removed.
//! * When serializing it, `serde_migrate` will automatically include a version tag.
//! * When deserializing it, `serde_migrate` will, if necessary, run a set of migration functions that you provide.
//!
//! ## Installation
//!
//! ```toml
//! # Add to cargo.toml
//! serde_migrate = "0"
//! ```
//!
//! ## Usage
//!
//! Here's an example of a struct with three versions.
//!
//! - In version 1, only field `a` exists.
//! - In version 2, field `b` is introduced.
//! - In version 3, field `c` is introduced, and field `b` is removed.
//!
//! The `mystruct_migrations::Migrate` trait is automatically generated, and you just
//! have to implement it with your migration logic.
//!
//! When deserializing, all migrations will run before the struct is returned.
//!
//! ```rust
//! use serde_migrate::{versioned, Versioned};
//!
//! #[versioned]
//! #[derive(PartialEq, Debug)]
//! struct MyStruct {
//!     pub a: u32,
//!     #[version(start = 2, end = 3)]
//!     pub b: String,
//!     #[version(start = 3)]
//!     pub c: u32,
//! }
//!
//! // The mystruct_migrations module is generated by the #[versioned] proc-macro.
//! // It contains the `migrate` trait, which you should implement.
//! impl mystruct_migrations::Migrate for MyStruct {
//!     // This function takes a `struct { a: u32 }`, which is how MyStruct looked in version 1
//!     fn to_v2(v: mystruct_migrations::MyStructV1) -> mystruct_migrations::MyStructV2 {
//!         mystruct_migrations::MyStructV2 {
//!             a: v.a,
//!             b: "321".to_string(),
//!         }
//!     }
//!
//!     // This function takes a `struct { a: u32, b: String }`, which is how MyStruct looked in version 2
//!     fn to_v3(v:mystruct_migrations::MyStructV2) -> mystruct_migrations::MyStructV3 {
//!         mystruct_migrations::MyStructV3 {
//!             a: v.a,
//!             c: v.b.parse().unwrap(),
//!         }
//!     }
//! }
//!
//! fn main() {
//!     // Decode a serialized version 1 struct. Both to_v2 and to_v3 will run.
//!     let decoded: MyStruct = serde_json::from_str::<Versioned<_>>(r#"{ "versions": { "rust_out::MyStruct": 1 }, "value": { "a": 123 } }"#).unwrap().0;
//!     // Check that the migration logic worked.
//!     // Note that the `b` field is not present in the deserialized data at all, because it was removed in version 3.
//!     assert_eq!(decoded, MyStruct {
//!        a: 123,
//!        c: 321
//!     });
//! }
//! ```
//!
//! ## Attributes
//!
//! The following attributes are available:
//!
//! * `#[version(start = x)]` - Indicates that the field was introduced in version x, and is still present in the latest version.
//! * `#[version(end = y)]` - Indicates that the field was removed in version y, and was present in all previous versions.
//! * `#[version(start = x, end = y)]` - Indicates that the field was introduced in version x, and removed in version y.
//!
//! The current version will be assumed to be the greatest version mentioned by any attribute. The first version is always version 1.
//!
//! ## Compatibility
//!
//! The #[macro@versioned] macro may currently be used on the following data types:
//!
//! * [x] Structs
//! * [ ] Enums
//! * [ ] Newtypes
//!
//! ## Limitations
//!
//! * Generics are currently not supported.
//!
//! ## How-tos
//!
//! Here are some useful tricks that you can use with this crate.
//!
//! ### Changing types
//!
//! You can change the type of a field by removing it in one version, and adding a field with the same name, but with a different type:
//!
//! ```rust
//! # use serde_migrate::{versioned, Versioned};
//!
//! #[versioned]
//! #[derive(PartialEq, Debug)]
//! struct MyStruct {
//!     #[version(end = 2)]
//!     pub value: String,
//!     #[version(start = 2)]
//!     pub value: u32,
//! }
//!
//! impl mystruct_migrations::Migrate for MyStruct {
//!     fn to_v2(v: mystruct_migrations::MyStructV1) -> mystruct_migrations::MyStructV2 {
//!         mystruct_migrations::MyStructV2 {
//!             value: v.value.parse().unwrap(),
//!         }
//!     }
//! }
//!
//! fn main() {
//!     let decoded: MyStruct = serde_json::from_str::<Versioned<_>>(r#"{ "versions": { "rust_out::MyStruct": 1 }, "value": { "value": "123" } }"#).unwrap().0;
//!     assert_eq!(decoded, MyStruct {
//!        value: 123,
//!     });
//! }
//! ```
//!
//! ### Keeping compatibility from the start
//!
//! If you add the #[macro@versioned] attribute without any version specifiers, the struct will be considered to be version 1.
//! This is useful when starting a project. Since there are no migrations to implement, you do not have to implement the `Migrate` trait.
//!
//! ```rust
//! # use serde_migrate::{versioned, Versioned};
//!
//! #[versioned]
//! struct MyStruct {
//!    pub value: u32,
//! }
//!
//! fn main() {
//!   let encoded = serde_json::to_string(&Versioned(&MyStruct { value: 123 })).unwrap();
//!   assert_eq!(encoded, r#"{"versions":{"rust_out::MyStruct":1},"value":{"value":123}}"#);
//! }
//! ```
//!
//! ## What counts as a breaking change?
//!
//! What exactly counts as a breaking change differs by serialization format. For example, in json, keys can be re-ordered without breaking compatibility, but
//! when using bincode, the order of fields matter.
//!
//! For the best compatibility, you should consider the following as breaking:
//!
//! * Removing a field
//! * Adding a field
//! * Changing the type of a field
//! * Changing the name of a field (only breaking in self-describing formats like json, but not in e.g. bincode)
//! * Changing the order of fields (only breaking in non-self-describing formats like bincode, but not in e.g. json)
//! * Changing the name of a type or module (this may cause this crate to not be able to find the version information) (TODO: Implement an alias attribute to help with this)
//! * Adding/removing serde attributes like `serialize_with` or `skip_serializing_if`.
use std::{fmt::Display, any::TypeId, cell::RefCell};

pub use serde_migrate_macros::versioned;

use std::collections::HashMap;

use serde::{Serialize, Serializer, ser::{self, SerializeStruct}, Deserialize, de::{Visitor, SeqAccess}, Deserializer};

thread_local! {
    pub static DESERIALIZATION_STATE: std::cell::RefCell<Option<DeserializationState>> = RefCell::new(None);
}

pub struct DeserializationState {
    pub versions: HashMap<TypeId, u32>,
    pub remaining_versions: HashMap<String, u32>,
}

impl DeserializationState {
    pub fn get_version<'de, T: 'static, D: Deserializer<'de>> (&mut self) -> Result<u32, D::Error> {
        if let Some(v) = self.versions.get(&std::any::TypeId::of::<T>()) {
            Ok(*v)
        } else if let Some(v) = self.remaining_versions.get(std::any::type_name::<T>()) {
            self.versions.insert(std::any::TypeId::of::<T>(), *v);
            Ok(*v)
        } else {
            // No version was found for this type.
            // This most likely means that the type was serialized before the #[versioned] attribute was added.
            // Therefore we should treat the data as version 1.
            Ok(1)

            // TODO: Maybe add a strict mode that throws an error?
            // Err(serde::de::Error::custom(format!("no version found for type {}", std::any::type_name::<T>())))
        }
    }
}

pub struct Versioned<T>(pub T);

impl<T: Serialize> Serialize for Versioned<T> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut vs = VersionSerializer::default();
        self.0.serialize(&mut vs).unwrap();
        let mut s = serializer.serialize_struct("Versioned", 2)?;
        s.serialize_field("versions", &vs.to_serialized_versions())?;
        s.serialize_field("value", &self.0)?;
        s.end()
    }
}

struct VersionedVisitor<T> {
    _p : std::marker::PhantomData<T>
}

impl<T> Default for VersionedVisitor<T> {
    fn default() -> Self {
        Self {
            _p: std::marker::PhantomData
        }
    }
}

#[derive(serde::Deserialize)]
#[serde(field_identifier, rename_all = "lowercase")]
enum VersionedField { Versions, Value }

impl<'de, T: Deserialize<'de>> Visitor<'de> for VersionedVisitor<T> {
    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("{ versions: Vec<u32>, value: T }")
    }

    type Value = Versioned<T>;

    fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>
    where
        V: SeqAccess<'de>,
    {
        let versions: HashMap<String, u32> = seq.next_element()?
            .ok_or_else(|| serde::de::Error::invalid_length(0, &self))?;
        let prev = DESERIALIZATION_STATE.with(|state| {
            state.replace(Some(DeserializationState {
                versions: Default::default(),
                remaining_versions: versions,
            }))
        });
        let value = seq.next_element();
        DESERIALIZATION_STATE.with(|state| {
            state.replace(prev);
        });
        let value = value?.ok_or_else(|| serde::de::Error::invalid_length(1, &self))?;
        Ok(Versioned(value))
    }

    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::MapAccess<'de>,
    {
        let mut version_found = false;
        let mut prev = None;
        while let Some(key) = map.next_key()? {
            match key {
                VersionedField::Versions => {
                    if version_found {
                        return Err(serde::de::Error::duplicate_field("versions"));
                    }
                    version_found = true;
                    let versions: HashMap<String, u32> = map.next_value()?;
                    DESERIALIZATION_STATE.with(|state| {
                        prev = state.replace(Some(DeserializationState {
                            versions: Default::default(),
                            remaining_versions: versions,
                        }));
                    });
                }
                VersionedField::Value => {
                    if !version_found {
                        return Err(serde::de::Error::custom("Missing field 'versions'. When deserializing a Versioned<T>, the field 'versions' must be present before the field 'value'."));
                    }
                    let value = map.next_value();
                    DESERIALIZATION_STATE.with(|state| {
                        state.replace(prev);
                    });
                    return Ok(Versioned(value?));
                }
            }
        }
        if version_found {
            DESERIALIZATION_STATE.with(|state| {
                state.replace(prev);
            });
        }
        Err(serde::de::Error::missing_field("value"))
    }
}

impl<'de, T: Deserialize<'de>> Deserialize<'de> for Versioned<T> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de> {



        deserializer.deserialize_struct("Versioned", &["versions", "value"], VersionedVisitor::default())
    }
}

#[derive(Default)]
pub struct VersionSerializer {
    pub seen: Vec<TypeId>,
    pub versions: Vec<(&'static str, u32)>,
    pub last: Option<TypeId>,
}

impl VersionSerializer {
    pub fn set_version<T: 'static>(&mut self, version: u32) {
        let id = TypeId::of::<T>();
        if Some(id) == self.last {
            return;
        }
        self.last = Some(id);
        if !self.seen.contains(&id) {
            self.seen.push(id);
            self.versions.push((std::any::type_name::<T>(), version));
        }
    }

    pub fn to_serialized_versions(self) -> HashMap<&'static str, u32> {
        self.versions.into_iter().collect()
    }
}

#[derive(Debug)]
pub struct DummyError {
    message: String
}

impl Display for DummyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for DummyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        None
    }
}

impl serde::de::Error for DummyError {
    fn custom<T>(msg:T) -> Self where T:Display {
        DummyError {
            message: msg.to_string()
        }
    }
}

impl serde::ser::Error for DummyError {
    fn custom<T>(msg:T) -> Self where T:Display {
        DummyError {
            message: msg.to_string()
        }
    }
}

type SerializationResult = Result<(), DummyError>;

impl<'a> serde::ser::Serializer for &'a mut VersionSerializer {
    fn is_human_readable(&self) -> bool {
        false
    }

    type Ok = ();

    type Error = DummyError;

    type SerializeSeq = Self;

    type SerializeTuple = Self;

    type SerializeTupleStruct = Self;

    type SerializeTupleVariant = Self;

    type SerializeMap = Self;

    type SerializeStruct = Self;

    type SerializeStructVariant = Self;

    // Note: It's important to #[inline] these functions as they
    // will be called from other crates, and they are not generic.
    // This means that by default they are not considered for inlining in rust.
    // The functions are tiny-though, so inlining them will cause no code bloat,
    // but it will give us a lot of performance.
    #[inline]
    fn serialize_bool(self, _v: bool) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_i8(self, _v: i8) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_i16(self, _v: i16) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_i32(self, _v: i32) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_i64(self, _v: i64) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_u8(self, _v: u8) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_u16(self, _v: u16) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_u32(self, _v: u32) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_u64(self, _v: u64) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_f32(self, _v: f32) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_f64(self, _v: f64) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_char(self, _v: char) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_str(self, _v: &str) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_bytes(self, _v: &[u8]) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Self::Ok, Self::Error>
    where
        T: serde::Serialize {
            value.serialize(self)
    }

    #[inline]
    fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_unit_struct(self, _name: &'static str) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_unit_variant(
        self,
        _name: &'static str,
        _variant_index: u32,
        _variant: &'static str,
    ) -> Result<Self::Ok, Self::Error> {
        Ok(())
    }

    #[inline]
    fn serialize_newtype_struct<T: ?Sized>(
        self,
        _name: &'static str,
        value: &T,
    ) -> Result<Self::Ok, Self::Error>
    where
        T: serde::Serialize {
            value.serialize(self)
    }

    #[inline]
    fn serialize_newtype_variant<T: ?Sized>(
        self,
        _name: &'static str,
        _variant_index: u32,
        _variant: &'static str,
        value: &T,
    ) -> Result<Self::Ok, Self::Error>
    where
        T: serde::Serialize {
            value.serialize(self)
    }

    #[inline]
    fn serialize_seq(self, _len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {
        Ok(self)
    }

    #[inline]
    fn serialize_tuple(self, _len: usize) -> Result<Self::SerializeTuple, Self::Error> {
        Ok(self)
    }

    #[inline]
    fn serialize_tuple_struct(
        self,
        _name: &'static str,
        _len: usize,
    ) -> Result<Self::SerializeTupleStruct, Self::Error> {
        Ok(self)
    }

    #[inline]
    fn serialize_tuple_variant(
        self,
        _name: &'static str,
        _variant_index: u32,
        _variant: &'static str,
        _len: usize,
    ) -> Result<Self::SerializeTupleVariant, Self::Error> {
        Ok(self)
    }

    #[inline]
    fn serialize_map(self, _len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {
        Ok(self)
    }

    #[inline]
    fn serialize_struct(
        self,
        _name: &'static str,
        _len: usize,
    ) -> Result<Self::SerializeStruct, Self::Error> {
        Ok(self)
    }

    #[inline]
    fn serialize_struct_variant(
        self,
        _name: &'static str,
        _variant_index: u32,
        _variant: &'static str,
        _len: usize,
    ) -> Result<Self::SerializeStructVariant, Self::Error> {
        Ok(self)
    }
}

impl<'a> ser::SerializeSeq for &'a mut VersionSerializer {
    // Must match the `Ok` type of the serializer.
    type Ok = ();
    // Must match the `Error` type of the serializer.
    type Error = DummyError;

    #[inline]
    fn serialize_element<T>(&mut self, value: &T) -> SerializationResult
    where
        T: ?Sized + Serialize,
    {
        value.serialize(&mut **self)
    }

    // Close the sequence.
    #[inline]
    fn end(self) -> SerializationResult {
        Ok(())
    }
}

impl<'a> ser::SerializeTuple for &'a mut VersionSerializer {
    type Ok = ();
    type Error = DummyError;

    #[inline]
    fn serialize_element<T>(&mut self, value: &T) -> SerializationResult
    where
        T: ?Sized + Serialize,
    {
        value.serialize(&mut **self)
    }

    #[inline]
    fn end(self) -> SerializationResult {
        Ok(())
    }
}

impl<'a> ser::SerializeTupleStruct for &'a mut VersionSerializer {
    type Ok = ();
    type Error = DummyError;

    #[inline]
    fn serialize_field<T>(&mut self, value: &T) -> SerializationResult
    where
        T: ?Sized + Serialize,
    {
        value.serialize(&mut **self)
    }

    #[inline]
    fn end(self) -> SerializationResult {
        Ok(())
    }
}


impl<'a> ser::SerializeTupleVariant for &'a mut VersionSerializer {
    type Ok = ();
    type Error = DummyError;

    #[inline]
    fn serialize_field<T>(&mut self, value: &T) -> SerializationResult
    where
        T: ?Sized + Serialize,
    {
        value.serialize(&mut **self)
    }

    #[inline]
    fn end(self) -> SerializationResult {
        Ok(())
    }
}

impl<'a> ser::SerializeMap for &'a mut VersionSerializer {
    type Ok = ();
    type Error = DummyError;

    #[inline]
    fn serialize_key<T>(&mut self, key: &T) -> SerializationResult
    where
        T: ?Sized + Serialize,
    {
        key.serialize(&mut **self)
    }

    #[inline]
    fn serialize_value<T>(&mut self, value: &T) -> SerializationResult
    where
        T: ?Sized + Serialize,
    {
        value.serialize(&mut **self)
    }

    #[inline]
    fn end(self) -> SerializationResult {
        Ok(())
    }
}

impl<'a> ser::SerializeStruct for &'a mut VersionSerializer {
    type Ok = ();
    type Error = DummyError;

    #[inline]
    fn serialize_field<T>(&mut self, _key: &'static str, value: &T) -> SerializationResult
    where
        T: ?Sized + Serialize,
    {
        value.serialize(&mut **self)
    }

    #[inline]
    fn end(self) -> SerializationResult {
        Ok(())
    }
}

impl<'a> ser::SerializeStructVariant for &'a mut VersionSerializer {
    type Ok = ();
    type Error = DummyError;

    #[inline]
    fn serialize_field<T>(&mut self, _key: &'static str, value: &T) -> SerializationResult
    where
        T: ?Sized + Serialize,
    {
        value.serialize(&mut **self)
    }

    #[inline]
    fn end(self) -> SerializationResult {
        Ok(())
    }
}