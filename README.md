# Serde Migrate

This crate provides an easy solution for handling migrations with `serde`.

The main idea is that:

* You provide a struct, with fields marked with attributes to indicate when they were introduced, and when they were removed.
* When serializing it, `serde_migrate` will automatically include a version tag.
* When deserializing it, `serde_migrate` will, if necessary, run a set of migration functions that you provide.

## Installation

```toml
# Add to cargo.toml
serde_migrate = "0"
```

## Usage

Here's an example of a struct with three versions.

* In version 1, only field `a` exists.
* In version 2, field `b` is introduced.
* In version 3, field `c` is introduced, and field `b` is removed.

The `mystruct_migrations::Migrate` trait is automatically generated, and you just
have to implement it with your migration logic.

When deserializing, all migrations will run before the struct is returned.

```rust
use serde_migrate::versioned;

#[versioned]
#[derive(PartialEq, Debug)]
struct MyStruct {
    pub a: u32,
    #[version(start = 2, end = 3)]
    pub b: String,
    #[version(start = 3)]
    pub c: u32,
}

// The mystruct_migrations module is generated by the #[versioned] proc-macro.
// It contains the `migrate` trait, which you should implement.
impl mystruct_migrations::Migrate for MyStruct {
    // This function takes a `struct { a: u32 }`, which is how MyStruct looked in version 1
    fn to_v2(v: mystruct_migrations::MyStructV1) -> mystruct_migrations::MyStructV2 {
        mystruct_migrations::MyStructV2 {
            a: v.a,
            b: "321".to_string(),
        }
    }

    // This function takes a `struct { a: u32, b: String }`, which is how MyStruct looked in version 2
    fn to_v3(v:mystruct_migrations::MyStructV2) -> mystruct_migrations::MyStructV3 {
        mystruct_migrations::MyStructV3 {
            a: v.a,
            c: v.b.parse().unwrap(),
        }
    }
}

fn main() {
    // Decode a serialized version 1 struct. Both to_v2 and to_v3 will run.
    let decoded: MyStruct = serde_json::from_str(r#"{ "version": 1, "value": { "a": 123 } }"#).unwrap();
    // Check that the migration logic worked.
    // Note that the `b` field is not present in the deserialized data at all, because it was removed in version 3.
    assert_eq!(decoded, MyStruct {
       a: 123,
       c: 321
    });
}
```

## Attributes

The following attributes are available:

* `#[version(start = x)]` - Indicates that the field was introduced in version x, and is still present in the latest version.
* `#[version(end = y)]` - Indicates that the field was removed in version y, and was present in all previous versions.
* `#[version(start = x, end = y)]` - Indicates that the field was introduced in version x, and removed in version y.

The current version will be assumed to be the greatest version mentioned by any attribute. The first version is always version 1.

## Compatibility

The #[macro@versioned] macro may currently be used on the following data types:

* [x] Structs
* [ ] Enums
* [ ] Newtypes

## Limitations

* Generics are currently not supported.

## How-tos

Here are some useful tricks that you can use with this crate.

### Changing types

You can change the type of a field by removing it in one version, and adding a field with the same name, but with a different type:

```rust
use serde_migrate::versioned;

#[versioned]
#[derive(PartialEq, Debug)]
struct MyStruct {
    #[version(end = 2)]
    pub value: String,
    #[version(start = 2)]
    pub value: u32,
}

impl mystruct_migrations::Migrate for MyStruct {
    fn to_v2(v: mystruct_migrations::MyStructV1) -> mystruct_migrations::MyStructV2 {
        mystruct_migrations::MyStructV2 {
            value: v.value.parse().unwrap(),
        }
    }
}

fn main() {
    let decoded: MyStruct = serde_json::from_str(r#"{ "version": 1, "value": { "value": "123" } }"#).unwrap();
    assert_eq!(decoded, MyStruct {
       value: 123,
    });
}
```

### Keeping compatibility from the start

If you add the #[macro@versioned] attribute without any version specifiers, the struct will be considered to be version 1.
This is useful when starting a project. Since there are no migrations to implement, you do not have to implement the `Migrate` trait.

```rust
use serde_migrate::versioned;

#[versioned]
struct MyStruct {
   pub value: u32,
}

fn main() {
  let encoded = serde_json::to_string(&MyStruct { value: 123 }).unwrap();
  assert_eq!(encoded, r#"{"version":1,"value":{"value":123}}"#);
}
```